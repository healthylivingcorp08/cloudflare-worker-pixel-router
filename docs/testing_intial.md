<write_file>
<path>PLAN_V4.1.md</path>
<content>
# Cloudflare Worker Pixel Router: Final Plan (v4.1 - Synchronous Confirmation Hybrid w/ Consistent Upsell Scrub)

## 1. Goal

Implement a reliable pixel/postback firing mechanism within a Cloudflare Worker. This system must:
*   Handle multiple payment providers (Sticky.io direct card processing, Sticky.io integrated PayPal).
*   Dynamically apply scrubbing rules based on Network (`affId`) and Affiliate (`c1`) **consistently across the entire order funnel (initial + upsells)** based on the initial checkout decision.
*   Determine the correct Sticky.io `campaignId` *before* initiating the payment transaction (for both initial and upsells, based on the initial scrub decision).
*   Reliably trigger conversion actions (pixels, server-to-server postbacks) *after* confirmed payment success, respecting a `payout_steps` rule (defaulting to step 1).
*   Operate **without** relying on webhooks from Sticky.io for payment confirmation.

## 2. Core Architecture (Synchronous Confirmation Hybrid - v4.1)

This plan uses synchronous confirmation methods combined with KV state management:

1.  **Upfront Scrub Decision:** A dedicated worker endpoint (`/api/decide-campaign`) is called by the frontend *before* payment initiation to determine the scrub outcome (`isScrub`) and the `targetCampaignId` for the initial Sticky.io transaction. This decision is stored in KV.
2.  **KV State Management:** Cloudflare KV stores the state associated with the entire transaction funnel, keyed by a unique `internal_txn_id` (generated by the frontend). This state includes tracking parameters, the initial scrub decision, payment status, order IDs, and idempotency flags for each step (initial, upsell 1, etc.). A separate KV namespace holds configuration.
3.  **Main Checkout Endpoint (`/`):** Acts as a proxy for the Sticky.io `NewOrder` API. Uses the pre-calculated `targetCampaignId`.
    *   For **Card Payments**, it handles the synchronous success/failure response. On success, it triggers the *initial checkout* actions (if `payout_steps >= 1`).
    *   For **PayPal Payments** (via Sticky.io integration), it initiates the flow and returns redirect info.
4.  **PayPal Return Endpoint (`/checkout/paypal-return`):** A dedicated worker endpoint handles the user's return from the PayPal flow. It confirms success via Sticky.io `order_view` and triggers the *initial checkout* actions (if `payout_steps >= 1`).
5.  **Upsell Endpoint (`/api/upsell`):** Handles subsequent upsell attempts.
    *   Retrieves the initial transaction state (including `isScrub`) from KV using the `internal_txn_id` passed from the frontend.
    *   Determines the appropriate `targetCampaignId` for the upsell based on the *initial* `isScrub` decision.
    *   Calls Sticky.io `new_upsell`.
    *   On synchronous success, triggers *upsell-specific* actions **only if** the `payout_steps` rule allows for the current upsell step number.
6.  **Centralized Action Triggering:** Helper functions (`triggerInitialActions`, `triggerUpsellActions`) encapsulate the logic for fetching state, checking idempotency per step, updating state, parameterizing actions based on the initial `isScrub` decision, executing server-side actions asynchronously, and returning client-side actions.

## 3. KV State Details (`PIXEL_STATE` Namespace)

This namespace stores the dynamic state for each transaction attempt.

*   **Key:** `txn_{internal_txn_id}`
*   **Value (JSON Object):**
    ```json
    {
      "internal_txn_id": "abc-123-def-456",
      "timestamp_created": "2025-04-21T21:50:00Z",
      "status": "pending" | "paypal_redirect" | "success" | "failed", // Overall status, primarily reflects initial checkout
      "trackingParams": { // Original tracking params
        "affId": "nva", "c1": "aff123", "campaignId": "sourceCampaignXYZ", "click_id": "xyz789", /* ... */
      },
      "scrubDecision": { // Based on initial checkout
        "isScrub": false,
        "targetCampaignId": "4" // Initial target campaign ID
      },
      "stickyOrderId_Initial": null | "1234567", // Initial order ID
      "stickyOrderId_Upsell1": null | "1234568", // Upsell 1 order ID
      "stickyOrderId_Upsell2": null | "1234569", // Upsell 2 order ID
      // ... potentially more upsell order IDs
      "paymentMethod_Initial": "card" | "paypal" | null,
      "processed_Initial": false, // Idempotency for initial checkout actions
      "processed_Upsell_1": false, // Idempotency for upsell 1 actions
      "processed_Upsell_2": false, // Idempotency for upsell 2 actions
      // ... potentially more upsell processed flags
      "timestamp_processed_Initial": null | "2025-04-21T21:52:00Z",
      "timestamp_processed_Upsell_1": null | "2025-04-21T21:53:00Z",
      // ...
    }
    ```
*   **TTL:** Recommended: **24-72 hours**.

## 4. KV Configuration Details (`PIXEL_CONFIG` Namespace)

This namespace stores the rules, settings, and action templates for the pixel router.

### 4.1. Scrub Rules & Campaign IDs

*   `global_scrub_percent`: (Number) Default scrub %.
    *   *Example Key:* `global_scrub_percent`, *Example Value:* `10`
*   `network_scrub_percent:{affId}`: (Number) Network-specific scrub %.
    *   *Example Key:* `network_scrub_percent:nva`, *Example Value:* `5`
*   `affiliate_scrub_percent:{c1}`: (Number) Affiliate-specific scrub % (overrides others).
    *   *Example Key:* `affiliate_scrub_percent:aff123`, *Example Value:* `0`
*   `normal_campaign_id`: (String) Sticky.io `campaignId` for non-scrubbed orders.
    *   *Example Key:* `normal_campaign_id`, *Example Value:* `"4"`
*   `scrub_campaign_id`: (String) Sticky.io `campaignId` for scrubbed orders.
    *   *Example Key:* `scrub_campaign_id`, *Example Value:* `"5"`

### 4.2. Payout Rules

*   `payout_steps`: (String) Controls up to which step actions are fired (e.g., "1" = initial only, "2" = initial + upsell 1).
    *   *Example Key:* `payout_steps`, *Example Value:* `"1"`

### 4.3. Action Lists (Keys pointing to Action Definitions)

*   `checkoutNormalActions`: (JSON Array of Strings) Actions for successful initial checkout.
    *   *Example Key:* `checkoutNormalActions`, *Example Value:* `["action_FacebookPurchase", "action_GoogleAnalyticsPurchase", "action_AffiliatePostback"]`
*   `upsell1NormalActions`: (JSON Array of Strings) Actions for successful upsell 1.
    *   *Example Key:* `upsell1NormalActions`, *Example Value:* `["action_FacebookUpsell", "action_AffiliateUpsellPostback"]`
*   `upsell2NormalActions`: (JSON Array of Strings) Actions for successful upsell 2.
    *   *Example Key:* `upsell2NormalActions`, *Example Value:* `["action_FacebookUpsell", "action_AffiliateUpsellPostback"]`
*   *(Optional: `checkoutScrubActions`, `upsell1ScrubActions` if needed)*

### 4.4. Action Definitions (Templates)

*   `action:{ActionName}`: (JSON Object) Defines the template for a specific pixel or postback.
    *   *Example Key:* `action_FacebookPurchase`
    *   *Example Value:*
        ```json
        {
          "type": "server-side", // or "client-side"
          "provider": "facebook_capi",
          "event_name": "Purchase",
          "url": "https://graph.facebook.com/v19.0/PARAM:FB_PIXEL_ID/events?access_token=PARAM:FB_ACCESS_TOKEN",
          "method": "POST",
          "headers": { "Content-Type": "application/json" },
          "body_template": {
            "data": [{
              "event_name": "Purchase",
              "event_time": "PARAM:TIMESTAMP_UNIX",
              "action_source": "website",
              "user_data": {
                "em": ["PARAM:USER_EMAIL_SHA256"],
                "ph": ["PARAM:USER_PHONE_SHA256"],
                "client_ip_address": "PARAM:IP_ADDRESS",
                "client_user_agent": "PARAM:USER_AGENT",
                "fbc": "PARAM:FBC",
                "fbp": "PARAM:FBP"
              },
              "custom_data": {
                "currency": "USD",
                "value": "PARAM:ORDER_TOTAL",
                "order_id": "PARAM:ORDER_ID",
                "content_ids": ["PARAM:PRODUCT_SKU"],
                "content_type": "product"
              },
              "event_source_url": "PARAM:PAGE_URL"
            }],
            "test_event_code": "PARAM:FB_TEST_CODE" // Optional
          }
        }
        ```
    *   *Example Key:* `action_AffiliatePostback`
    *   *Example Value:*
        ```json
        {
          "type": "server-side",
          "provider": "generic_postback",
          "url": "https://network.example.com/postback?clickid=PARAM:CLICK_ID&amount=PARAM:ORDER_SUBTOTAL&orderid=PARAM:ORDER_ID&is_scrub=PARAM:IS_SCRUB",
          "method": "GET"
          // Note: triggerActions logic should handle setting amount=0 if isScrub=true
        }
        ```
    *   *Example Key:* `action_GoogleAnalyticsPurchase` (Client-Side Example)
    *   *Example Value:*
        ```json
        {
          "type": "client-side",
          "provider": "google_analytics_ga4",
          "script_template": "gtag('event', 'purchase', { transaction_id: 'PARAM:ORDER_ID', value: PARAM:ORDER_TOTAL, currency: 'USD', items: [{ item_id: 'PARAM:PRODUCT_SKU', item_name: 'PARAM:PRODUCT_NAME', price: PARAM:PRODUCT_PRICE, quantity: PARAM:PRODUCT_QUANTITY }] });"
        }
        ```

## 5. Endpoint Logic (Renumbered)

### 5.1. `/api/decide-campaign` (POST)

*   **Input:** JSON body `{ internal_txn_id, affId, c1, campaignId, ...trackingParams }`
*   **Logic:**
    1.  Fetch scrub rules, `normalCampaignId`, `scrubCampaignId` from `PIXEL_CONFIG`.
    2.  Determine applicable scrub % (`c1` > `affId` > Global).
    3.  Calculate `isScrub`.
    4.  Determine `targetCampaignId`.
    5.  Construct initial KV state (`status: 'pending'`, `processed_Initial: false`, etc.).
    6.  Write state to `PIXEL_STATE` KV with TTL.
*   **Output:** JSON body `{ targetCampaignId }`

### 5.2. `/` (POST - Checkout Proxy & Card Confirmation)

*   **Input:** Checkout payload, payment details, `targetCampaignId`, `internal_txn_id`.
*   **Logic:**
    1.  Extract `internal_txn_id`. Determine `paymentMethod`.
    2.  Update `PIXEL_STATE`: set `paymentMethod_Initial`.
    3.  Construct `NewOrder` payload (using `targetCampaignId`, include `internal_txn_id`).
    4.  Call Sticky.io `NewOrder`.
    5.  Update `PIXEL_STATE`: store `stickyOrderId_Initial`.
    6.  **Handle Response:**
        *   **If Card Payment & Success (`response_code == "100"`):**
            *   Call `triggerInitialActions(internal_txn_id, response, env, context)`.
            *   Return `{ success: true, orderId: response.order_id, clientSideActions: result.clientSideActions }`.
        *   **If Card Payment & Failure:** Update `PIXEL_STATE` (`status: 'failed'`). Return error.
        *   **If PayPal Payment & Redirect:** Update `PIXEL_STATE` (`status: 'paypal_redirect'`). Return redirect info.
        *   **If PayPal Payment & Failure:** Update `PIXEL_STATE` (`status: 'failed'`). Return error.
*   **Output:** Varies.

### 5.3. `/checkout/paypal-return` (GET - User Redirect Target)

*   **Input:** `?txn={internal_txn_id}`.
*   **Logic:**
    1.  Extract `internal_txn_id`. Read state from `PIXEL_STATE`. Handle errors/already processed.
    2.  Check `state.stickyOrderId_Initial`.
    3.  Call Sticky.io `order_view` using `stickyOrderId_Initial`.
    4.  Check `order_view` response for success.
    5.  **Handle Response:**
        *   If **Success**:
            *   Call `triggerInitialActions(internal_txn_id, orderViewResponse, env, context)`.
            *   Prepare data/redirect to confirmation page.
        *   If **Failure/Pending**: Update `PIXEL_STATE` (`status: 'failed'`). Redirect to error/pending page.
*   **Output:** HTTP Redirect or data.

### 5.4. `/api/upsell` (POST)

*   **Input:** Upsell payload (`offers`, `previous_order_id`), `internal_txn_id` (passed from frontend).
*   **Logic:**
    1.  Extract `internal_txn_id`.
    2.  Read initial state from `PIXEL_STATE`. Handle errors.
    3.  Determine `currentUpsellStep` (e.g., 1 or 2).
    4.  Fetch `payout_steps`, `normal_campaign_id`, `scrub_campaign_id` from `PIXEL_CONFIG`.
    5.  Get initial `isScrub = state.scrubDecision.isScrub`.
    6.  Determine `targetUpsellCampaignId` based on `isScrub`.
    7.  Construct `new_upsell` payload (using `targetUpsellCampaignId`, `previous_order_id`).
    8.  Call Sticky.io `new_upsell`.
    9.  Update `PIXEL_STATE`: store `stickyOrderId_Upsell_{N}`.
    10. **Handle Response:**
        *   If **Success (`response_code == "100"`):**
            *   **Check Payout:** If `parseInt(payout_steps) > currentUpsellStep`:
                *   Call `triggerUpsellActions(internal_txn_id, currentUpsellStep, response, env, context)`.
            *   Return `{ success: true, orderId: response.order_id, clientSideActions: result?.clientSideActions ?? [] }`.
        *   If **Failure:** Return `{ success: false, error: response.error_message }`.
*   **Output:** JSON response.

## 6. Action Triggering Helpers (Renumbered)

### 6.1. `triggerInitialActions`

*   **Signature:** `async function triggerInitialActions(internal_txn_id, confirmationData, env, context)`
*   **Logic:**
    1.  Read state from `PIXEL_STATE`.
    2.  **Idempotency:** If `state.processed_Initial === true`, return `{ clientSideActions: [] }`.
    3.  **Update KV:** Mark `processed_Initial: true`, `status: 'success'`, set `timestamp_processed_Initial`.
    4.  Fetch `payout_steps` from `PIXEL_CONFIG` (default "1").
    5.  **Check Payout:** If `parseInt(payout_steps) >= 1`:
        *   Fetch initial action keys (e.g., `checkoutNormalActions`) from `PIXEL_CONFIG`.
        *   Fetch definitions from `PIXEL_CONFIG`. Filter server/client.
        *   Parameterize using `state.trackingParams`, `confirmationData`, `state.scrubDecision.isScrub`.
        *   Execute server-side actions asynchronously.
        *   Return `{ clientSideActions: processedClientSideActions }`.
    6.  Else (payout_steps < 1): Return `{ clientSideActions: [] }`.

### 6.2. `triggerUpsellActions`

*   **Signature:** `async function triggerUpsellActions(internal_txn_id, upsellStepNum, confirmationData, env, context)`
*   **Logic:**
    1.  Read state from `PIXEL_STATE`.
    2.  **Idempotency:** Check/Update step-specific flag (e.g., `processed_Upsell_1`). If already true, return `{ clientSideActions: [] }`.
    3.  Fetch upsell action keys (e.g., `upsell1NormalActions`) from `PIXEL_CONFIG`.
    4.  Fetch definitions from `PIXEL_CONFIG`. Filter server/client.
    5.  Parameterize using `state.trackingParams`, `confirmationData`, `state.scrubDecision.isScrub`.
    6.  Execute server-side actions asynchronously.
    7.  Return `{ clientSideActions: processedClientSideActions }`.

## 7. Sequence Diagram (Conceptual Update - Renumbered)

*   The `/api/upsell` call would retrieve state from `PIXEL_STATE` using `internal_txn_id`.
*   It would call `new_upsell` using a `targetCampaignId` derived from the *initial* `isScrub` decision.
*   On success, it calls `triggerUpsellActions` which checks the `payout_steps` rule (from `PIXEL_CONFIG`) and the step-specific idempotency flag before firing actions.

This revised plan (v4.1) ensures consistent scrubbing across the funnel and respects the `payout_steps` rule, while still operating without Sticky.io webhooks.
</content>
</write_file>