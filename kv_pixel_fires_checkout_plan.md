# Cloudflare Worker Pixel Router: Final Plan (v4.1 - Synchronous Confirmation Hybrid w/ Consistent Upsell Scrub)

## 1. Goal

Implement a reliable pixel/postback firing mechanism within a Cloudflare Worker. This system must:
*   Handle multiple payment providers (Sticky.io direct card processing, Sticky.io integrated PayPal).
*   Dynamically apply scrubbing rules based on Network (`affId`) and Affiliate (`c1`) **consistently across the entire order funnel (initial + upsells)** based on the initial checkout decision.
*   Determine the correct Sticky.io `campaignId` *before* initiating the payment transaction (for both initial and upsells, based on the initial scrub decision).
*   Reliably trigger conversion actions (pixels, server-to-server postbacks) *after* confirmed payment success, respecting a `payout_steps` rule (defaulting to step 1).
*   Operate **without** relying on webhooks from Sticky.io for payment confirmation.

## 2. Core Architecture (Synchronous Confirmation Hybrid - v4.1)

This plan uses synchronous confirmation methods combined with KV state management:

1.  **Upfront Scrub Decision:** A dedicated worker endpoint (`/api/decide-campaign`) is called by the frontend *before* payment initiation to determine the scrub outcome (`isScrub`) and the `targetCampaignId` for the initial Sticky.io transaction. This decision is stored in KV.
2.  **KV State Management:** Cloudflare KV stores the state associated with the entire transaction funnel, keyed by a unique `internal_txn_id` (generated by the frontend). This state includes tracking parameters, the initial scrub decision, payment status, order IDs, and idempotency flags for each step (initial, upsell 1, etc.). A separate KV namespace holds configuration.
3.  **Main Checkout Endpoint (`/`):** Acts as a proxy for the Sticky.io `NewOrder` API. Uses the pre-calculated `targetCampaignId`.
    *   For **Card Payments**, it handles the synchronous success/failure response. On success, it triggers the *initial checkout* actions (if `payout_steps >= 1`).
    *   For **PayPal Payments** (via Sticky.io integration), it initiates the flow and returns redirect info.
4.  **PayPal Return Endpoint (`/checkout/paypal-return`):** A dedicated worker endpoint handles the user's return from the PayPal flow. It confirms success via Sticky.io `order_view` and triggers the *initial checkout* actions (if `payout_steps >= 1`).
5.  **Upsell Endpoint (`/api/upsell`):** Handles subsequent upsell attempts.
    *   Retrieves the initial transaction state (including `isScrub`) from KV using the `internal_txn_id` passed from the frontend.
    *   Determines the appropriate `targetCampaignId` for the upsell based on the *initial* `isScrub` decision.
    *   Calls Sticky.io `new_upsell`.
    *   On synchronous success, triggers *upsell-specific* actions **only if** the `payout_steps` rule allows for the current upsell step number.
6.  **Centralized Action Triggering:** Helper functions (`triggerInitialActions`, `triggerUpsellActions`) encapsulate the logic for fetching state, checking idempotency per step, updating state, parameterizing actions based on the initial `isScrub` decision, executing server-side actions asynchronously, and returning client-side actions.

## 3. KV State Details (`PIXEL_STATE` Namespace)

This namespace stores the dynamic state for each transaction attempt.

*   **Key:** `txn_{internal_txn_id}`
*   **Value (JSON Object):**
    ```json
    {
      "internal_txn_id": "abc-123-def-456",
      "timestamp_created": "2025-04-21T21:50:00Z",
      "status": "pending" | "paypal_redirect" | "success" | "failed", // Overall status, primarily reflects initial checkout
      "trackingParams": { // Original tracking params from frontend (captured via Everflow click pixel or similar)
        "affId": "nva", // EF affiliate_id
        "c1": "aff123", // EF affiliate_id (often duplicated)
        "c2": "769", // EF offer_id
        "sub1": "sub1_val",
        "sub2": "sub2_val",
        "sub3": "sub3_val",
        "sub4": "sub4_val",
        "sub5": "sub5_val",
        "uid": "user_id_val",
        "source_id": "source_val",
        "click_id": "xyz789", // EF transaction_id (_ef_transaction_id)
        "campaignId": "sourceCampaignXYZ", // Original campaignId before potential scrub/remap
        "fbc": "fb.1...", // Facebook click id
        "fbp": "fb.1...", // Facebook browser id
        // Include other relevant params passed from frontend: UTMs etc.
      },
      "scrubDecision": { // Based on initial checkout
        "isScrub": false,
        "targetCampaignId": "4" // Initial target campaign ID for Sticky.io
      },
      "stickyOrderId_Initial": null | "1234567", // Initial order ID
      "stickyOrderId_Upsell1": null | "1234568", // Upsell 1 order ID
      "stickyOrderId_Upsell2": null | "1234569", // Upsell 2 order ID
      // ... potentially more upsell order IDs
      "paymentMethod_Initial": "card" | "paypal" | null,
      "processed_Initial": false, // Idempotency for initial checkout actions
      "processed_Upsell_1": false, // Idempotency for upsell 1 actions
      "processed_Upsell_2": false, // Idempotency for upsell 2 actions
      // ... potentially more upsell processed flags
      "timestamp_processed_Initial": null | "2025-04-21T21:52:00Z",
      "timestamp_processed_Upsell_1": null | "2025-04-21T21:53:00Z",
      // ...
    }
    ```
*   **TTL:** Recommended: **24-72 hours**.

## 4. KV Configuration Details (`PIXEL_CONFIG` Namespace)

This namespace stores the rules, settings, and action templates for the pixel router.

### 4.1. Scrub Rules & Campaign IDs

*   `global_scrub_percent`: (Number) Default scrub %.
    *   *Example Key:* `global_scrub_percent`, *Example Value:* `10`
*   `network_scrub_percent:{affId}`: (Number) Network-specific scrub %.
    *   *Example Key:* `network_scrub_percent:nva`, *Example Value:* `5`
*   `affiliate_scrub_percent:{c1}`: (Number) Affiliate-specific scrub % (overrides others).
    *   *Example Key:* `affiliate_scrub_percent:aff123`, *Example Value:* `0`
*   `normal_campaign_id`: (String) Sticky.io `campaignId` for non-scrubbed orders.
    *   *Example Key:* `normal_campaign_id`, *Example Value:* `"4"`
*   `scrub_campaign_id`: (String) Sticky.io `campaignId` for scrubbed orders.
    *   *Example Key:* `scrub_campaign_id`, *Example Value:* `"5"`

### 4.2. Payout Rules

*   `payout_steps`: (String) Controls up to which step actions are fired (e.g., "1" = initial only, "2" = initial + upsell 1).
    *   *Example Key:* `payout_steps`, *Example Value:* `"1"`

### 4.3. Action Lists (Keys pointing to Action Definitions)

*   `checkoutNormalActions`: (JSON Array of Strings) Actions for successful initial checkout.
    *   *Example Key:* `checkoutNormalActions`, *Example Value:* `["action_FacebookPurchase", "action_GoogleAnalyticsPurchase", "action_EverflowPostback", "action_EverflowConversionPixel"]`
*   `upsell1NormalActions`: (JSON Array of Strings) Actions for successful upsell 1.
    *   *Example Key:* `upsell1NormalActions`, *Example Value:* `["action_FacebookUpsell", "action_EverflowPostback"]` // Example: Maybe only postback on upsell
*   `upsell2NormalActions`: (JSON Array of Strings) Actions for successful upsell 2.
    *   *Example Key:* `upsell2NormalActions`, *Example Value:* `["action_FacebookUpsell", "action_EverflowPostback"]`
*   *(Optional: `checkoutScrubActions`, `upsell1ScrubActions` if needed, might just use Normal actions and modify params)*

### 4.4. Action Definitions (Templates)

*   `action:{ActionName}`: (JSON Object) Defines the template for a specific pixel or postback.

    *   *Example Key:* `action_FacebookPurchase`
    *   *Example Value:* (Note: Using raw email/phone placeholders)
        ```json
        {
          "type": "server-side",
          "provider": "facebook_capi",
          "event_name": "Purchase",
          "url": "https://graph.facebook.com/v19.0/PARAM:FB_PIXEL_ID/events?access_token=PARAM:FB_ACCESS_TOKEN",
          "method": "POST",
          "headers": { "Content-Type": "application/json" },
          "body_template": {
            "data": [{
              "event_name": "Purchase",
              "event_time": "PARAM:TIMESTAMP_UNIX",
              "action_source": "website",
              "user_data": {
                "em": ["PARAM:USER_EMAIL"], // Raw email
                "ph": ["PARAM:USER_PHONE"], // Raw phone (consider normalization)
                "client_ip_address": "PARAM:IP_ADDRESS",
                "client_user_agent": "PARAM:USER_AGENT",
                "fbc": "PARAM:FBC",
                "fbp": "PARAM:FBP"
              },
              "custom_data": {
                "currency": "USD",
                "value": "PARAM:ORDER_TOTAL",
                "order_id": "PARAM:ORDER_ID",
                "content_ids": ["PARAM:PRODUCT_SKU"],
                "content_type": "product"
              },
              "event_source_url": "PARAM:PAGE_URL"
            }],
            "test_event_code": "PARAM:FB_TEST_CODE" // Optional
          }
        }
        ```

    *   *Example Key:* `action_GoogleAnalyticsPurchase` (Client-Side Example)
    *   *Example Value:*
        ```json
        {
          "type": "client-side",
          "provider": "google_analytics_ga4",
          "script_template": "gtag('event', 'purchase', { transaction_id: 'PARAM:ORDER_ID', value: PARAM:ORDER_TOTAL, currency: 'USD', items: [{ item_id: 'PARAM:PRODUCT_SKU', item_name: 'PARAM:PRODUCT_NAME', price: PARAM:PRODUCT_PRICE, quantity: PARAM:PRODUCT_QUANTITY }] });"
        }
        ```

    *   *Example Key:* `action_EverflowPostback` (Server-Side Example)
    *   *Example Value:*
        ```json
        {
          "type": "server-side",
          "provider": "everflow_postback",
          "url": "https://www.c6orlterk.com/?nid=1318&transaction_id=PARAM:CLICK_ID", // nid=1318 hardcoded as per example
          "method": "GET"
          // Note: triggerActions logic could potentially add amount=PARAM:ORDER_SUBTOTAL&adv1=PARAM:ORDER_ID etc. if needed and if isScrub=false
        }
        ```

    *   *Example Key:* `action_EverflowConversionPixel` (Client-Side Example)
    *   *Example Value:*
        ```json
        {
          "type": "client-side",
          "provider": "everflow",
          // Assumes Everflow SDK (everflow.js) is loaded globally by the frontend site.
          // Worker only returns the specific conversion call.
          // offer_id=769 hardcoded as per example. Could be PARAM:EVERFLOW_OFFER_ID if needed.
          "script_template": "<script type=\"text/javascript\">EF.conversion({ offer_id: 769 });</script>"
        }
        ```

## 5. Parameter Population Strategy (`PARAM:` Replacement)

This section outlines how the `PARAM:` placeholders within the action definition templates (stored in `PIXEL_CONFIG`) are replaced with actual values inside the `triggerInitialActions` and `triggerUpsellActions` helper functions.

### 5.1. Context

*   Parameter replacement occurs *after* a successful payment confirmation (synchronous response or `order_view` check) and *before* executing the server-side action (`fetch`) or returning the client-side action script.
*   The helper functions (`triggerInitialActions`, `triggerUpsellActions`) will have access to the necessary data sources.

### 5.2. Data Sources

The functions will gather data from the following sources to populate parameters:

1.  **`PIXEL_STATE` KV Entry (`state`):**
    *   Contains the original tracking parameters (`state.trackingParams.*`) passed from the frontend (e.g., `affId`, `c1`, `c2`, `click_id`, `fbc`, `fbp`, `utm_source`, `sub1`-`sub5`, `uid`, `source_id`).
    *   Contains the scrub decision (`state.scrubDecision.isScrub`).
2.  **Sticky.io Confirmation Data (`confirmationData`):**
    *   The response object from the successful `NewOrder` (for cards), `order_view` (for PayPal return), or `new_upsell` call.
    *   Contains order details like `order_id`, amounts (`total_amount`, `sub_total`, product prices), customer details (`email`, `phone`, address info), product details (`product_id`, `sku`, `quantity`). *Note: Exact field names depend on the specific Sticky.io API response structure.*
3.  **Incoming Request Object (`request`):**
    *   Available within the main `fetch` handler and potentially passed down or accessed via context.
    *   Provides `request.headers` (for `CF-Connecting-IP`, `User-Agent`), `request.url`.
    *   Provides access to cookies if parsed (e.g., for `_fbc`, `_fbp` if not passed in URL params).
4.  **Worker Environment/Secrets (`env`):**
    *   Contains sensitive API keys, tokens, and static configuration values (e.g., `FB_ACCESS_TOKEN`, `FB_PIXEL_ID`, `FB_TEST_CODE`).
5.  **Derived/Generated Values:**
    *   Current timestamp (Unix format, ISO format).
    *   Hardcoded values specific to the action (e.g., `currency: 'USD'`).
    *   *Optional:* Normalized values (e.g., phone numbers with non-digits removed).

### 5.3. Mapping Examples (Illustrative)

The replacement logic will involve looking up the `PARAM:` key and retrieving/calculating the corresponding value:

*   `PARAM:ORDER_ID` -> `confirmationData.order_id`
*   `PARAM:ORDER_TOTAL` -> `confirmationData.total_amount` (or relevant total field)
*   `PARAM:ORDER_SUBTOTAL` -> `confirmationData.sub_total` (or relevant subtotal field)
*   `PARAM:CLICK_ID` -> `state.trackingParams.click_id` (This is the Everflow `transaction_id`)
*   `PARAM:AFFID` -> `state.trackingParams.affId` (or `c1`)
*   `PARAM:C1` -> `state.trackingParams.c1`
*   `PARAM:C2` -> `state.trackingParams.c2` (Everflow `offer_id`)
*   `PARAM:SUB1` -> `state.trackingParams.sub1`
*   `PARAM:IS_SCRUB` -> `state.scrubDecision.isScrub` (as boolean or "true"/"false" string)
*   `PARAM:FB_PIXEL_ID` -> `env.FB_PIXEL_ID` (from Secrets)
*   `PARAM:FB_ACCESS_TOKEN` -> `env.FB_ACCESS_TOKEN` (from Secrets)
*   `PARAM:FB_TEST_CODE` -> `env.FB_TEST_CODE` (from Secrets, optional)
*   `PARAM:IP_ADDRESS` -> `request.headers.get('CF-Connecting-IP')`
*   `PARAM:USER_AGENT` -> `request.headers.get('User-Agent')`
*   `PARAM:FBC` -> `state.trackingParams.fbc` (or parsed from cookie if available)
*   `PARAM:FBP` -> `state.trackingParams.fbp` (or parsed from cookie if available)
*   `PARAM:TIMESTAMP_UNIX` -> `Math.floor(Date.now() / 1000)`
*   `PARAM:USER_EMAIL` -> `confirmationData.email` (Raw email)
*   `PARAM:USER_PHONE` -> `confirmationData.phone` (Raw phone, consider normalization like removing non-digits if required by endpoint)
*   `PARAM:PRODUCT_SKU` -> Extract from `confirmationData.products` array (might need logic for single vs multiple products)
*   `PARAM:PAGE_URL` -> `request.url`

### 5.4. Implementation Notes

*   A dedicated utility function (e.g., `populateParameters(templateStringOrObject, dataSources)`) should handle the replacement logic.
*   The function must gracefully handle cases where a parameter source or specific value is missing (e.g., return an empty string, omit the field, or throw an error depending on requirements).
*   Consider caching frequently accessed secrets or configuration from `env` if performance becomes an issue.
*   Implement necessary transformations like phone number normalization if required by specific endpoints.

## 6. Endpoint Logic (Renumbered)

### 6.1. `/api/decide-campaign` (POST)

*   **Input:** JSON body `{ internal_txn_id, affId, c1, c2, click_id, sub1, ..., campaignId, ...otherTrackingParams }`
*   **Logic:**
    1.  Fetch scrub rules, `normalCampaignId`, `scrubCampaignId` from `PIXEL_CONFIG`.
    2.  Determine applicable scrub % (`c1` > `affId` > Global).
    3.  Calculate `isScrub`.
    4.  Determine `targetCampaignId`.
    5.  Construct initial KV state (`status: 'pending'`, `processed_Initial: false`, etc., include all `trackingParams`).
    6.  Write state to `PIXEL_STATE` KV with TTL.
*   **Output:** JSON body `{ targetCampaignId }`

### 6.2. `/` (POST - Checkout Proxy & Card Confirmation)

*   **Input:** Checkout payload, payment details, `targetCampaignId`, `internal_txn_id`.
*   **Logic:**
    1.  Extract `internal_txn_id`. Determine `paymentMethod`.
    2.  Update `PIXEL_STATE`: set `paymentMethod_Initial`.
    3.  Construct `NewOrder` payload (using `targetCampaignId`, include `internal_txn_id`).
    4.  Call Sticky.io `NewOrder`.
    5.  Update `PIXEL_STATE`: store `stickyOrderId_Initial`.
    6.  **Handle Response:**
        *   **If Card Payment & Success (`response_code == "100"`):**
            *   Call `triggerInitialActions(internal_txn_id, response, env, context, request)`.
            *   Return `{ success: true, orderId: response.order_id, clientSideActions: result.clientSideActions }`.
        *   **If Card Payment & Failure:** Update `PIXEL_STATE` (`status: 'failed'`). Return error.
        *   **If PayPal Payment & Redirect:** Update `PIXEL_STATE` (`status: 'paypal_redirect'`). Return redirect info.
        *   **If PayPal Payment & Failure:** Update `PIXEL_STATE` (`status: 'failed'`). Return error.
*   **Output:** Varies.

### 6.3. `/checkout/paypal-return` (GET - User Redirect Target)

*   **Input:** `?txn={internal_txn_id}`.
*   **Logic:**
    1.  Extract `internal_txn_id`. Read state from `PIXEL_STATE`. Handle errors/already processed.
    2.  Check `state.stickyOrderId_Initial`.
    3.  Call Sticky.io `order_view` using `stickyOrderId_Initial`.
    4.  Check `order_view` response for success.
    5.  **Handle Response:**
        *   If **Success**:
            *   Call `triggerInitialActions(internal_txn_id, orderViewResponse, env, context, request)`.
            *   Prepare data/redirect to confirmation page (passing client-side actions if needed).
        *   If **Failure/Pending**: Update `PIXEL_STATE` (`status: 'failed'`). Redirect to error/pending page.
*   **Output:** HTTP Redirect or data.

### 6.4. `/api/upsell` (POST)

*   **Input:** Upsell payload (`offers`, `previous_order_id`), `internal_txn_id` (passed from frontend).
*   **Logic:**
    1.  Extract `internal_txn_id`.
    2.  Read initial state from `PIXEL_STATE`. Handle errors.
    3.  Determine `currentUpsellStep` (e.g., 1 or 2).
    4.  Fetch `payout_steps`, `normal_campaign_id`, `scrub_campaign_id` from `PIXEL_CONFIG`.
    5.  Get initial `isScrub = state.scrubDecision.isScrub`.
    6.  Determine `targetUpsellCampaignId` based on `isScrub`.
    7.  Construct `new_upsell` payload (using `targetUpsellCampaignId`, `previous_order_id`).
    8.  Call Sticky.io `new_upsell`.
    9.  Update `PIXEL_STATE`: store `stickyOrderId_Upsell_{N}`.
    10. **Handle Response:**
        *   If **Success (`response_code == "100"`):**
            *   **Check Payout:** If `parseInt(payout_steps) > currentUpsellStep`:
                *   Call `triggerUpsellActions(internal_txn_id, currentUpsellStep, response, env, context, request)`.
            *   Return `{ success: true, orderId: response.order_id, clientSideActions: result?.clientSideActions ?? [] }`.
        *   If **Failure:** Return `{ success: false, error: response.error_message }`.
*   **Output:** JSON response.

## 7. Action Triggering Helpers (Renumbered)

### 7.1. `triggerInitialActions`

*   **Signature:** `async function triggerInitialActions(internal_txn_id, confirmationData, env, context, request)`
*   **Logic:**
    1.  Read state from `PIXEL_STATE`.
    2.  **Idempotency:** If `state.processed_Initial === true`, return `{ clientSideActions: [] }`.
    3.  **Update KV:** Mark `processed_Initial: true`, `status: 'success'`, set `timestamp_processed_Initial`.
    4.  Fetch `payout_steps` from `PIXEL_CONFIG` (default "1").
    5.  **Check Payout:** If `parseInt(payout_steps) >= 1`:
        *   Fetch initial action keys (e.g., `checkoutNormalActions`) from `PIXEL_CONFIG`.
        *   Fetch definitions from `PIXEL_CONFIG`. Filter server/client.
        *   **Parameterize:** Use a utility function to replace `PARAM:` placeholders in definitions using data sources: `state`, `confirmationData`, `request`, `env` (as detailed in Section 5). Handle potential modifications based on `isScrub` (e.g., zeroing out amount in postback URL).
        *   Execute server-side actions asynchronously (`context.waitUntil(...)`).
        *   Return `{ clientSideActions: processedClientSideActions }`.
    6.  Else (payout_steps < 1): Return `{ clientSideActions: [] }`.

### 7.2. `triggerUpsellActions`

*   **Signature:** `async function triggerUpsellActions(internal_txn_id, upsellStepNum, confirmationData, env, context, request)`
*   **Logic:**
    1.  Read state from `PIXEL_STATE`.
    2.  **Idempotency:** Check/Update step-specific flag (e.g., `processed_Upsell_1`). If already true, return `{ clientSideActions: [] }`.
    3.  Fetch upsell action keys (e.g., `upsell1NormalActions`) from `PIXEL_CONFIG`.
    4.  Fetch definitions from `PIXEL_CONFIG`. Filter server/client.
    5.  **Parameterize:** Use a utility function to replace `PARAM:` placeholders in definitions using data sources: `state`, `confirmationData`, `request`, `env` (as detailed in Section 5). Handle potential modifications based on `isScrub`.
    6.  Execute server-side actions asynchronously (`context.waitUntil(...)`).
    7.  Return `{ clientSideActions: processedClientSideActions }`.

## 8. Sequence Diagram (Conceptual Update - Renumbered)

*   The `/api/upsell` call would retrieve state from `PIXEL_STATE` using `internal_txn_id`.
*   It would call `new_upsell` using a `targetCampaignId` derived from the *initial* `isScrub` decision.
*   On success, it calls `triggerUpsellActions` which checks the `payout_steps` rule (from `PIXEL_CONFIG`) and the step-specific idempotency flag before parameterizing and firing actions.

This revised plan (v4.1) ensures consistent scrubbing across the funnel and respects the `payout_steps` rule, while still operating without Sticky.io webhooks.